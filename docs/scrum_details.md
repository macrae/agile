# Scrum Details

- [Scrum Details](#scrum-details)
  - [Estimating / Sizing](#estimating--sizing)
  - [Scrum Workflow](#scrum-workflow)
  - [Sprint Planning: a timebox](#sprint-planning-a-timebox)
  - [Standups](#standups)
  - [Scrum Roles](#scrum-roles)
    - [Product Owner](#product-owner)
    - [Scrum Master](#scrum-master)
    - [Developer / the team](#developer--the-team)
  - [Process & Process Improvements](#process--process-improvements)
  - [Self-organizing teams](#self-organizing-teams)
  - [Development as a team sport](#development-as-a-team-sport)
    - [Sizing and duration/velocity & metrics](#sizing-and-durationvelocity--metrics)
  - [Attention to quality](#attention-to-quality)
  - [Avoid Waste](#avoid-waste)

Goal: Create a sense of abundance
* Small teams
* Daily check-ins
* Flow / focus / avoid task switching
* Timeboxing

## Estimating / Sizing
Two-pass release sizing (“the steve bockman method”)

## Scrum Workflow

List project requirements => Prioritize work => do the work based on current business priorities => deliver working functionality

## Sprint Planning: a timebox

## Standups

## Scrum Roles

### Product Owner
The product owner’s job is to Prioritize, and determine the Value of work.

* The “what”
* Plus the who and the why
* Communicate product vision
* Craft product roadmap
* Write story cards
* Own, order, maintaoin the product backlog
* Detail top-of-backlog stories & acceptance tests
* Always available to explain stories
* Decide what to do when problems arise
* Ensure the value of work team performs
* Perform acceptance tests
* Manage stakeholders

### Scrum Master

* Facilitator, "servant leader"


### Developer / the team

* The how


## Process & Process Improvements

## Self-organizing teams
Self-organizing teams are - by definition - highly communicative and collaborative, but the nature of Data Science work can tend away from these behaviors and veer towards individual research silos, which is a problem for the Data Science team trying to ship software products and not just research.

So how do we create Data Science teams that are self-organizing? In our opinion, it’s not any one thing, but many small things. These small tweaks in how we communicate and interact w/ each other will, over time, allow every team member to step up and lead in their own way.

## Development as a team sport

1.	Paired/mob programming

    a.	In lieu of a single DS working on a story, if the story is large enough, assign two. We need cultural leaders who can elevate this behavior and lead by example. May need to get people better trained w/ git – there is a fear I see that many DS have wrt working on the same feature branch.
2.	In-person code reviews

    a.	Team-wide, in-person code reviews to create transparency and a shared understanding/vocabulary of our software.
3.	Design Session?

In-person team planning and two-pass sizing <= something here…?

When we create a safe spaces for every team member to voice their opinion…

* Happiness => Productivity
* Psychological safty
* Blame free envs
* Micro-management bad
* It is leadership’s role to identify the outcome they’d like achieved (ideally related to a customer behavior) and then it’s up to the team (PM, Technical Lead and IC’s) to identify, vet and deliver the feature set that accomplishes that customer behavior-based outcome. By mirco-managing the process of identifying and vetting the solution, or in specifying constraints of technology/methodology, we oppose self-organization and force people to step back in lieu of step up and lead in their own way.
* Respect and trust
* Definition of Done
* Timeboxing
* Dev team decides what to pull
* Retros & demos

### Sizing and duration/velocity & metrics
We recommend two-pass, relative story sizing to estimate story points.

In lieu of creating size estimates that attempt to measure, for example, the total number of days required to complete a story we compare one story to another and ask: “Is this story as big as this one? Is it smaller? Or is it larger?” Working our way through all stories like this produces a relative order of stories. This is the first pass.

We then take a second pass assigning story points from the Fibonacci sequence, starting with the smallest story. The smallest story is given a size of 1 and we work our way up the list asking if the next story is half-again as much effort as the preceding story. If it is, it’s given the next value in the Fibonacci sequence. This is the second pass.

Using two-pass, relative sizing we can reasonably size stories over a 3 to 7-month range, or about 100 to 150 user stories in a single sizing exercise.

Note, that epics cannot live in the top of the backlog because by definition they will take longer than one sprint.

Velocity is a trailing average.
Can also use this sizing method to measure tech debt, but we need a method to calculate }value..
Sprint planning – the team pulls cards – they are not assigned by anyone!
Need actual QA and testing & EaaS process for each sprint.
Fist to five after planning, also after standup.


## Attention to quality


## Avoid Waste
Do as little as possible (MVP)
